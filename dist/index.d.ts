// Generated by dts-bundle-generator v6.0.0

export interface ICardWithoutAmount {
	/**
	 * The amount of the card specified within the deck.
	 */
	name: string;
	/**
	 * The set code of the card.
	 */
	set?: string;
	/**
	 * The collector number of the card within the specific set.
	 */
	collectors?: number;
	/**
	 * The ID of the card specific to MTG Online.
	 */
	mtgoID?: string;
	multiverseid?: string;
}
export interface ICard extends ICardWithoutAmount {
	/**
	 * The name of the card specified within the deck.
	 */
	amount: number;
}
export interface ICardXmlObject {
	Quantity: string;
	Name: string;
	CatID: string;
}
export interface IDeck<CARD extends CardModel = CardModel> {
	/**
	 * deck name
	 */
	name?: string;
	/**
	 * An array of `CardModel` for the main deck.
	 */
	deck: CARD[];
	/**
	 * An array of `CardModel` for the sideboard.
	 */
	sideboard: CARD[];
	/**
	 * If a companion is specified in the input will be available, otherwise null.
	 */
	companion?: CARD;
	/**
	 * If a commander is specified in the input will be available, otherwise null.
	 */
	commander?: CARD;
}
export declare const SymDecklistType: unique symbol;
export declare const enum EnumDecklistType {
	mtgo = "mtgo",
	mtga = "mtga",
	mtgify = "mtgify"
}
export declare class CardModel implements ICard {
	name: string;
	amount: number;
	set?: string;
	collectors?: number;
	mtgoID?: string;
	constructor(rawInput: string | ICardXmlObject | ICard);
	protected parseString(rawInput: string): ICard;
	protected parseObject<T extends ICardXmlObject | ICard>(rawInputObject: T): ICard;
	toCardString(): string;
}
export declare abstract class AbstractDeck<CARD extends CardModel = CardModel> implements IDeck<CARD> {
	/**
	 * deck name
	 */
	name?: string;
	/**
	 * If the parsing of the decklist was successful. Note: this does not necessarily mean the input was well formed.
	 */
	readonly valid: boolean;
	/**
	 * An array of `CardModel` for the main deck.
	 */
	deck: CARD[];
	/**
	 * An array of `CardModel` for the sideboard.
	 */
	sideboard: CARD[];
	/**
	 * If a companion is specified in the input will be available, otherwise null.
	 */
	companion?: CARD;
	/**
	 * If a commander is specified in the input will be available, otherwise null.
	 */
	commander?: CARD;
	protected constructor();
	toDeckListString(): string;
	protected _newCardModel(rawInput: any, amount?: number): CARD;
}
export declare class Decklist<CARD extends CardModel = CardModel> extends AbstractDeck<CARD> {
	readonly [SymDecklistType]: EnumDecklistType.mtga;
	constructor(rawInput: string | Uint8Array, logError?: boolean);
	protected _newCardModel(rawInput: string | ICardXmlObject | ICard, amount?: number): CARD;
}
export declare class MTGO<CARD extends CardModel = CardModel> extends AbstractDeck<CARD> {
	readonly [SymDecklistType]: EnumDecklistType.mtgo;
	constructor(xml: string | Uint8Array, logError?: boolean);
	protected _newCardModel(rawInput: string | ICardXmlObject | ICard, amount?: number): CARD;
}
export declare class MtgifyDecklist<CARD extends CardModel = CardModel> extends AbstractDeck<CARD> {
	readonly [SymDecklistType]: EnumDecklistType.mtgify;
	constructor(rawInput: string | Uint8Array, logError?: boolean);
	protected _newCardModel(rawInput: string | ICardXmlObject | ICard, amount?: number): CARD;
}
export declare function parseString(rawInput: string): ICard;
/**
 * AMOUNT NAME (SET) COLLECTORS
 * @example 2 Trelasarra, Moon Dancer (AFR) 236
 */
export declare function toCardString(card: ICard): string;
export declare function toMtgifyCardString(card: ICard): string;
/**
 * NAME (SET) COLLECTORS
 * @example Trelasarra, Moon Dancer (AFR) 236
 */
export declare function toCardStringWithoutAmount(card: ICardWithoutAmount): string;
export declare function toDeckListString(deck: IDeck): string;
export declare function autoParse(rawInput: string | Uint8Array): MTGO | Decklist | MtgifyDecklist;
export default autoParse;

export {};
